# Reflection - Fuqi Cui
_A reflection on your experiences in the final project, focusing on what you learned from the experience, divided into a subsection for each team member._

# Problem-framing Learnings:
During problem framing, our team brainstormed and iterated extensively on potential directions (the idea brainstorming session alone took us >2 hours!), drawing on lessons we had learned from our own personal projects. A major insight was the importance of authentic demand. It is tempting to build a product that feels personally compelling, but without validating that a broader audience shares that need, the idea risks becoming developer-centric rather than user-centric. Because our team consists of four members with diverse backgrounds and habits, we were able to cross-examine each idea from multiple perspectives, helping us converge on a problem space grounded in real user frustration rather than personal preference. This is a benefit of team work I observed compared to my experiences with my personal project.

The ethical analysis requirement also significantly shaped our early design decisions. Knowing we would need to explicitly consider harms, misuse, or unexpected consequences prevented us from choosing certain ideas For example, one of our initial idea is to build a “Kalshi for friends” app, which immediate raised fairness, legal, or privacy concerns. This early constraint pushed us toward more thoughtful features and problem-framing, and we intentionally tried to build a product that can add value to our users. It also trained us to think of ethics not as an afterthought, but as a design parameter that should guide feasibility, scope, and feature prioritization early on.

# Project Pitch and Classmate Feedback
Preparing and delivering our project pitch before building anything helped clarify what aspects of the problem framing resonated with users and what remained confusing. Our classmates' feedback surfaced several issues regarding clarity, user flow, and potential misinterpretations of our features. As a team, we examined these comments and incorporated the feedback into our design revisions. One of the major design change we made is to build a Google Extension, which works as an additional frontend interface for our app. Making these adjustments before implementation allowed us to avoid costly redesign later and ensured that development proceeded with a much sharper understanding of user needs.

# Concept Design
The largest conceptual shift in our design came from recognizing weaknesses in our initial software design (really appreciate Eagon's feedback on our app during the meeting!). Early on, our representations of Items and user profiles were not completely modular. This created conceptual leakage that would have made future changes brittle and difficult to maintain.

After discussing this with Eagon during our meetings, we reworked these concepts to restore proper modularity by cleanly separating user-related attributes, item-related data, and community feedback logic. This not only aligned our design with best practices taught in class but also dramatically improved the clarity of our functional design. The experience taught me how modularity is not just an abstract principle but something that directly influences how intuitive, extensible, and maintainable a system becomes.

# Technical learning and implementation
The iterative, incremental development process reinforced the value of controlled context and structured tooling. On the backend, using the context tool and properly maintaining each code version's history explicitly allowed me to build features piece by piece, verify generated code, and debug efficiently. This workflow felt modular and predictable.

On the frontend, however, using Claude Code, which automatically manages large context windows, initially caused problems. Because it had access to the entire project, the model sometimes modified files I did not intend to change, leading to merge conflicts or unexpected UI behavior. Later in the project, I learned to constrain its scope by specifying exactly which files it was allowed to edit. This also helps manage the credit issue that occurred for Claude Code. This experience strengthened my understanding of how to collaborate with AI tools effectively: maintaining human control over structure while leveraging automation for speed. This is essentially the Human-in-Loop idea we learned in class!

# User Testing
User testing was also one of the most valuable components of the team project, especially because it was not part of the personal project workflow. Conducting structured tests with real users gave us a completely different lens into our product. Even though we were deeply familiar with the app, users approached it with fresh eyes, which helped reveal usability issues, confusing flows, and mismatches between our assumptions and their actual behavior.

Several insights surfaced only through testing, allowing us to understand how users interpreted certain elements differently from what we intended. These findings prompted us to revisit our feature explanations, onboarding flow, and interface clarity. User testing ultimately grounded our design decisions in real evidence rather than intuition, and it reinforced how essential iterative testing is for building a product that genuinely aligns with user expectations.

# Team Work
1. I love team SEAL! I think we have a pretty even split of work, and all of us are very active and passionate about this project. We all worked hard, and we help each other throughout the process.
2. One of the right choice we did is to maintain a clean and organized Git workflow: implement new features with branching, pull requests, and code reviews. These git workflows kept our codebase clean and allowed us to develop in parallel with minimal friction. Midway through the project, we also shifted from role-based divisions (backend vs. frontend vs. extension) to feature-based divisions (i.e., Swipe feature, Queue feature, shopping cart feature, Google extension feature, stats feature), which improved ownership, reduced context switching, and aligned our work more closely with the functional design. This also boosted the dev productivity.

# Personal Takeaways
1. This project clarified for me that modern software development requires not only technical execution but also thoughtful design and problem framing. With LLM-assisted coding becoming increasingly powerful, the differentiator becomes knowing what to build and how to structure it, not simply writing code. The course significantly strengthened my ability to think at this higher level—abstracting concepts, reasoning about modularity, and anticipating user needs.

2. Finally, working in a collaborative SWE environment taught me how teams iterate on ideas, negotiate design decisions, and coordinate development workflows. The experience of evolving our design—from brainstorming to pitching, refining, implementing, and integrating—was one of the most valuable aspects of the entire class.